#!/usr/bin/perl -CS

# This script builds an archive release of a project. It should be run thus:
# $ cd <the project directory>
# $ build_scheme

use strict;
use Getopt::Long;
use File::Temp qw(tempdir);
use Digest::MD5 qw(md5 md5_hex md5_base64);
use JSON::PP;

GetOptions
(
);

my $keyIndex = 0;
my %keyOrder = map {$_, $keyIndex++} qw(token row column offset subnodes);

sub sortKeys
{
	return $keyOrder{$JSON::PP::a} <=> $keyOrder{$JSON::PP::b};
}

my $json = JSON::PP->new->pretty->canonical->sort_by(\&sortKeys);

foreach my $path (@ARGV)
{
	search(\&handle_file, $path);
}

sub handle_file
{
	my $path = join "/", @_;
	if ($path =~ /\.c$/ || $path =~ /\.m$/)
	{
		if (system "clang", "-I.", "-Wno-everything", "-o", "/dev/null", $path)
		{
			die $path;
		}
				
		my $content = read_file('UTF-8', $path);

		warn $path,"\n";
		my $root = tokeniseContent($content);
	
		if ($root)
		{
			$root = removeAnonymousTokens($root);	
		}
		
		if ($root)
		{
# 			$root = ;	
		}
	
		if ($root)
		{
			my $content = encodeTree($root);
			$content =~ s/^  //gm;
			print $content;
# 			print qq(<link rel="stylesheet" type="text/css" href="/Volumes/Personal/Repositories/c-flat/cblang.css">).encodeXML($root);
			exit;
		}
	}
	
	return 1;
}

sub tokeniseContent
{
	my ($content) = @_;
	
	my $operatorSet = quotemeta('!%&*+,-./:;<=>?@\\~^|');

	my @tokens = grep {length} $content =~ m!(\/\*.*?\*/)|(\/\/[^\n]*)|("(?:\\.|[^"])*")|('(?:\\.|[^'])*')|(#[^\n]*)|([A-Za-z][_0-9A-Za-z]+)|(\d+(?:\.\d+)?)|( +)|(\n)|([${operatorSet}]+)|(.)!gs;

	my $root = {'subnodes'=>[]};
	my @stack = ($root);
	
	my $row = 1;
	my $column = 1;
	my $offset = 0;
	
	{
		my $subnodes = [];
		my $node = {'token'=>';', 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
		push @{$stack[-1]{'subnodes'}}, $node;
		push @stack, $node;
	}
	
	{
		my $subnodes = [];
		my $node = {'token'=>',', 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
		push @{$stack[-1]{'subnodes'}}, $node;
		push @stack, $node;
	}	
	
	foreach my $token (@tokens)
	{
		if ($token =~ /^[{\(\[]$/)
		{
			{
				my $subnodes = [];
				my $node = {'token'=>$token, 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
				push @{$stack[-1]{'subnodes'}}, $node;
				push @stack, $node;
			}
			
			{
				my $subnodes = [];
				my $node = {'token'=>';', 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
				push @{$stack[-1]{'subnodes'}}, $node;
				push @stack, $node;
			}
			
			{
				my $subnodes = [];
				my $node = {'token'=>',', 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
				push @{$stack[-1]{'subnodes'}}, $node;
				push @stack, $node;
			}	
		}
		elsif ($token =~ /^[}\)\]]$/)
		{
			# leave the nodes last ,
			pop @stack;
			
			# leave the nodes last ;
			pop @stack;
			
		
			$stack[-1]{'token'} .= $token;
			pop @stack; # nodes			
		}
		elsif ($token =~ /^;$/)
		{
			# leave the nodes last ,
			pop @stack;
		
			# leave the nodes last item
			pop @stack;
			
			{
				my $subnodes = [];
				my $node = {'token'=>';', 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
				push @{$stack[-1]{'subnodes'}}, $node;
				push @stack, $node;
			}	
			{
				my $subnodes = [];
				my $node = {'token'=>',', 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
				push @{$stack[-1]{'subnodes'}}, $node;
				push @stack, $node;
			}	
		}
		elsif ($token =~ /^(\/\*)|(\/\/)|(#)/)
		{
			push @{$stack[-1]{'subnodes'}}, {'token'=>$token, 'row' => $row, 'column' => $column, 'offset' => $offset, 'subnodes'=>[]};

			# leave the nodes last ,
			pop @stack;
		
			# leave the nodes last item
			pop @stack;
			
			{
				my $subnodes = [];
				my $node = {'token'=>';', 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
				push @{$stack[-1]{'subnodes'}}, $node;
				push @stack, $node;
			}	
			{
				my $subnodes = [];
				my $node = {'token'=>',', 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
				push @{$stack[-1]{'subnodes'}}, $node;
				push @stack, $node;
			}	
		}

		elsif ($token =~ /^,$/)
		{
			# leave the nodes last item
			pop @stack;
			
			{
				my $subnodes = [];
				my $node = {'token'=>',', 'subnodes'=>$subnodes, 'row' => $row, 'column' => $column, 'offset' => $offset};
				push @{$stack[-1]{'subnodes'}}, $node;
				push @stack, $node;
			}	
		}
		elsif ($token !~ /^[ \t\n]+$/)
		{
			push @{$stack[-1]{'subnodes'}}, {'token'=>$token, 'row' => $row, 'column' => $column, 'offset' => $offset, 'subnodes'=>[]};
		}
		
		if ($token =~ /\n/)
		{
			$row += () = $token =~ /\n/g;
			$column = 0;
		}
		$column += length $token =~ /([^\n]+)$/;

		$offset += length $token;
	}
	
	return $root;
}

sub removeAnonymousTokens
{
	my ($node, @supernodes) = @_;
	
	my $cleanNode = mergeNodes($node);
	
	my @subnodes;
	foreach my $subnode (@{$node->{'subnodes'}})
	{
		push @subnodes, removeAnonymousTokens($subnode, $node, @supernodes);
	}
	
	if ($node->{'token'} =~ /^[;,]$/)
	{
		if (@supernodes && (@{$supernodes[0]{'subnodes'}} == 1 || !@subnodes))
		{
			return @subnodes;
		}
	}
	
	
	if (defined $node->{'token'} || !@supernodes)
	{
		$cleanNode->{'subnodes'} = \@subnodes;
		return $cleanNode;
	}
	else
	{
		return @subnodes;
	}
}

sub mergeNodes
{
	my ($node, @nodes) = @_;
		
	my $mergedNode = {'subnodes'=>[], 'row' => $node->{'row'}, 'column' => $node->{'column'}, 'offset' => $node->{'offset'}};
	
	foreach my $node ($node, @nodes)
	{
		$mergedNode->{'token'} .= $node->{'token'} if length $node->{'token'};
		push @{$mergedNode->{'subnodes'}}, @{$node->{'subnodes'}} if $node->{'subnodes'};
	
	}
	return $mergedNode;
}

sub cleanExport
{
	my ($node, @supernodes) = @_;
	
	my @subnodes;
	foreach my $subnode (@{$node->{'subnodes'}})
	{
		push @subnodes, cleanExport($subnode, $node, @supernodes);
	}
	
	if (@subnodes)
	{
		if (defined $node->{'token'})
		{
			return {'token' => $node->{'token'}, 'subnodes' => \@subnodes};
		}
		else
		{
			return @subnodes;
		}
	}
	elsif (defined $node->{'token'})
	{
		return $node->{'token'};
	}
	else
	{
		return;
	}
}

use DirHandle;

sub search
{
	my ($block, @path) = @_;
	my $path = join '/', @path;
	if ($block->(@path) && -d $path)
	{
		my $handle = DirHandle->new($path) || return;
		my @files = $handle->read();
		$handle->close();
		foreach my $file (@files)
		{
			next if $file =~ /^\.{1,2}$/;
			search($block, @path, $file);
		}
	}
}

sub read_file
{
	my ($encoding, $path) = @_;
	open(my($file), '<:encoding('.$encoding.')', $path) || die "read_file $!: $path\n";
	my $content = "";
	while(<$file>) {
		$content .= $_;
	}
	close $file;
	return $content;
}

sub write_file
{
	my ($encoding, $path, $content) = @_;
	if (defined $content)
	{
		my $parent = $path;
		$parent =~ s!/[^/]+$!!;
		if (!-e $parent)
		{
			system "mkdir", "-p", $parent;
		}
		if (!-e $path || read_file($encoding, $path) ne $content)
		{
			open(my($file), '>:encoding('.$encoding.')', $path) || die "write_file $!: $path\n";
			print $file $content;
			close $file;
		}
	}
	elsif (-e $path)
	{
		system "rm", "-f", $path;
	}
}

BEGIN
{
	my $json = JSON::PP->new->canonical(1)->pretty(1)->relaxed(1)->allow_nonref();

	sub Dumper
	{
		if (@_ > 1)
		{
			return $json->encode(\@_);
		}
		else
		{
			return $json->encode($_[0]);
		}
	}
}

sub encodeXML
{
	my ($node, @supernodes) = @_;
	
	my $content = "";
	my $token = $node->{'token'};
	if ($node->{'token'} eq '#import')
	{
		$content .= "<div class='import'>";
		$content .= "<pre>";		
		$content .= $token;
		$content .= "</pre>";
	}
	elsif ($node->{'token'} eq '#include')
	{
		$content .= "<div class='include'>";
		$content .= "<pre>";		
		$content .= $token;
		$content .= "</pre>";
	}
	else
	{
		$content .= "<div>";
		if (length $node->{'token'})
		{
			$token =~ s/&/&#38;/g;
			$token =~ s/</&#60;/g;
			$token =~ s/>/&#62;/g;
			$content .= "<pre>";		
			$content .= $token;
			$content .= "</pre>";
		}
	}
	
	
	foreach my $subnode (@{$node->{'subnodes'}})
	{
		$content .= encodeXML($subnode, $node, @supernodes);
	}
	$content .= "</div>";
	return $content;
}

sub encodeTree
{
	my ($node, @supernodes) = @_;
	my $content = "";
	if (exists $node->{'token'})
	{
		$content .= $node->{'token'};
		$content .= "\n";
	}
	
	foreach my $subnode (@{$node->{'subnodes'}})
	{
		$content .= encodeTree($subnode, $node, @supernodes);
	}
	
	if (exists $node->{'token'})
	{
		$content =~ s/\n/\n  /g;
		$content =~ s/ +$//;
		$content = "  ".$content;
	}
	return $content;
}

sub encodeC
{
	my ($node) = @_;
	my $content = "";
	encodeContent(\$content, 0, $node);
	return $content;
}

sub encodeContent
{
	my ($contentRef, $depth, $node, @supernodes) = @_;
	
	if ('HASH' ne ref $node)
	{
		die Dumper(@supernodes);
	}
	
	if (($$contentRef =~ /\n$/ || $$contentRef eq '') && $node->{'token'} ne '{}')
	{
		$$contentRef .= "    " x $depth;
	}
	elsif ($$contentRef =~ /}$/)
	{
		$$contentRef .= "\n";
		$$contentRef .= "    " x $depth;
		$depth++;
	}
	elsif ($$contentRef !~ /[ \(\{\[]$/)
	{
		$$contentRef .= " ";
	}
	
	if ($node->{'token'} eq '()')
	{	
		$$contentRef =~ s/ $//;
		$$contentRef .= "(";
	}
	elsif ($node->{'token'} eq '{}')
	{
		$$contentRef .= "\n";
		$$contentRef .= "    " x $depth;
		$$contentRef .= "{\n";
		$depth++;
	}
	
	foreach my $subnode (@{$node->{'subnodes'}})
	{
		encodeContent($contentRef, $depth, $subnode, $node, @supernodes);
	}

	if ($node->{'token'} eq '()')
	{
		$$contentRef =~ s/,$//;

		$$contentRef .= ")";
	}
	elsif ($node->{'token'} eq '{}')
	{
		$depth--;
		if ($$contentRef =~ /\n$/ || $$contentRef eq '')
		{
			$$contentRef .= "    " x $depth;
		}

		$$contentRef .= "}";
		
		if (@supernodes && $supernodes[0]{'token'} ne ';')
		{
			$$contentRef .= "\n";
		}
		
	}
	elsif ($node->{'token'} eq ';')
	{
		$$contentRef =~ s/,$//;
		if ($$contentRef =~ /\n$/ || $$contentRef eq '')
		{
			$$contentRef .= "    " x $depth;
		}
		
		$$contentRef .= ";\n";
	}
	elsif ($node->{'token'} =~ /^\/\*/ || $node->{'token'} =~ /^#/)
	{
		$$contentRef .= $node->{'token'};
		$$contentRef .= "\n";
	}
	else
	{
		$$contentRef .= $node->{'token'};
	}
}
